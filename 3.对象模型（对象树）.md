## 4.对象模型（对象树）

![image-20201022110358681](images\image-20201022110358681.png)

![image-20201022112141139](images\image-20201022112141139.png)

- 在Qt中创建对象时候，会提供一个parent指针，来指定为父控件。

- 有一个父类（或没有），和他的children列表。新建子控件，会在其父类的children列表中添加子空间的指针。

- 父窗口析构，这个列表中的所有对象也会被析构。

- 子控件显示在父控件的**坐标系统**，会被父控件的**边界剪裁**

  ![image-20201022140722958](images\image-20201022140722958.png)

一定程度上解决了内存的问题：

- 对象数中对象的顺序未定义，所以销毁对象的顺序也是未定以的。
- 任何对象树中的对象delete的时候，**1.若此对象有parent，则自动将其从parent中的children列表中删除；2.如果有孩子，则自动delete每一个孩子。QT保证没有QObject会被delete两次，这是由析构顺序决定的。**

（问题：如何实现从父对象的孩子列表中删除呢？？）

![image-20201022141309039](images\image-20201022141309039.png)

```cpp
{
    QWidget window;
    QPushButton quit=QPushButton("退出",&window);
}
```







C++标准：**局部对象的析构谁徐应该按照其创建顺序的相反过程。**所以上面没问题。



但是，如果使用下面的代码，就有问题了：

```cpp
{
	QPushButton quit("Quit");
	QWidget window;
	quit.setParent(&window);
}
```

情况就不同了，**析构顺序就有了问题**。可以看到，上面的window先被析构，因为他是最后一个创建的对象。在析构过程中，它会调用子对象列表中的每个对象的析构函数。也就是说。此时quit已经被析构了。然后代码继续执行，在window被西沟之后，quit也会被析构（因为quit也是个局部变量，超出作用域会被析构）。但是此时已经是**第二次调用quit析构函数**了，C++不允许两次调用析构函数，因此，**程序崩溃了**。



**<u>所以创建对象的时候，请创建在堆区，就不会有这样的问题发生</u>。**

**在QT中，尽量在构造的时候就指定parent对象，并且大胆在堆上创建**。

![image-20201022142646714](images\image-20201022142646714.png)

（这个图画错了，。应该是按钮A先定义，再定义`QWidget m`。这样析构才会出问题。）

